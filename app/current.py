
from .url_prefixes import BUTTONS_URL_PREFIX, CLEANING_SCHEDULES_URL_PREFIX
from .type_aliases import RecordGet, WeekYear, Name, TaskName
from .type_utils import taskname_to_var_name
from .more_info import MORE_INFO_URL_PREFIX
from .date_utils import todays_week_year, tuple_week_year, tuple_next_week_year, str_week_year
from .html_utils import HtmlTable, html_a, html_p
from .database import record

import threading
from flask import Blueprint, redirect


buttons = Blueprint("buttons", __name__)

class Button:
    def __init__(self, taskname:TaskName, no:int = 0) -> None:
        self.taskname = taskname
        self.no = no
        buttons.add_url_rule(
            f"/{taskname_to_var_name(taskname)}{no}",
            endpoint = f"{taskname_to_var_name(taskname)}{no}",
            view_func= self._create_route()
        ) 

    def _create_route(self):
        def button_route():
            this_week:RecordGet = current.current_week_record()
            name = tuple(this_week[self.taskname][0].keys())[self.no]
            this_week[self.taskname][0][name] = not this_week[self.taskname][0][name]
            return redirect(CLEANING_SCHEDULES_URL_PREFIX)
        return button_route

    def get_url(self):
        return f"{CLEANING_SCHEDULES_URL_PREFIX}{BUTTONS_URL_PREFIX}/{taskname_to_var_name(self.taskname)}{self.no}"



all_buttons = {
    "House Vacuuming": (Button("House Vacuuming", 0),  Button("House Vacuuming", 1)),
    "Kitchen Cleaning": (Button("Kitchen Cleaning", 0),  Button("Kitchen Cleaning", 1)),
    "Basement Cleaning": (Button("Basement Cleaning"),),
    "Plastic Garbage": (Button("Plastic Garbage"),),
    "Organic Garbage": (Button("Organic Garbage"),),
    "Cardboard Garbage": (Button("Cardboard Garbage"),),
    "Toilet Cleaning": (Button("Toilet Cleaning"),),
}

class Current:
    def __init__(self) -> None:
        self.week_no, self.year = None, None
        self.reset_to_current_week()
        self.timer_thread = None
        self.stop_event = threading.Event()
        self.lock = threading.Lock()
        self.start_timer(120)
    
    def reset_to_current_week(self) -> None:
        self.week_no, self.year = tuple_week_year(todays_week_year())
    
    def next_week(self):
        self.week_no, self.year = tuple_next_week_year(self.week_no, self.year)
    
    def current_week_record(self) -> RecordGet:
        return record[str_week_year((self.week_no, self.year))]
    
    def week_year(self) -> str:
        return str_week_year((self.week_no, self.year))

    def html_table(self, week_year:WeekYear) -> str: 
        week:RecordGet = record[week_year]
        table = HtmlTable(len(week), 4, "center")
        for row_no, item in enumerate(week.items()):
            taskname, task = item
            task:tuple[dict[Name:bool], str]
            # The first column
            table[row_no, 0] = html_p(taskname, "taskname")
            # The second column
            for no, item in enumerate(task[0].items()):
                name, state = item
                table[row_no, 1] += html_p(html_a(
                    all_buttons[taskname][no].get_url(), 
                    name,
                    "green" if state else "red",
                ))
            # The Third Column
            table[row_no, 2] += html_p(task[1])
            # The Forth Column
            table[row_no, 3] += html_a(
                CLEANING_SCHEDULES_URL_PREFIX + MORE_INFO_URL_PREFIX + f"/{taskname_to_var_name(taskname)}",
                "More Info"
            )
        return str(table)
    
    # Methods below are generated by ChatGPT-4o, with some modification    
    def start_timer(self, seconds=120):
        """
        Starts or restarts the timer to call `reset_to_current_week` every `seconds`.
        """
        self.stop_timer()  # Ensure no duplicate timers
        self.stop_event.clear()

        def timer_task():
            while not self.stop_event.wait(seconds):  # Wait for the interval or stop event
                # print("current is now reset")
                self.reset_to_current_week()
        
        self.timer_thread = threading.Thread(target=timer_task, daemon=True)
        self.timer_thread.start()
        # print(f"Timer started with interval of {seconds} seconds.")
    
    def reset_timer(self, seconds=120):
        """
        Resets the timer with a new interval or restarts the current one.
        """
        # print(f"Timer reset with interval of {seconds} seconds.")
        self.start_timer(seconds)
    
    def stop_timer(self):
        """
        Stops the timer if it is running.
        """
        with self.lock:
            if self.timer_thread and self.timer_thread.is_alive():
                self.stop_event.set()
                self.timer_thread.join()
                # print("Timer stopped.")
                self.timer_thread = None

current = Current()

