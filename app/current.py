
from .constants import BUTTONS_URL_PREFIX, MORE_INFO_URL_PREFIX
from .constants import CLEANING_SCHEDULES_URL_PREFIX
from .type_aliases import RecordGet, WeekYear, Name, TaskName
from .type_utils import taskname_to_url_part, tuple_to_weekyear
from .date_utils import get_today_weekyear, weekyear_to_tuple
from .date_utils import next_week_weekyear
from .html_utils import HtmlTable, html_a, html_p
from .database import record

# threading is for the reset timer used by `current` to reset every given interval
import threading
from flask import Blueprint, redirect

CURRENT_DEFAULT_TIMER_INTERVAL = 120

# Due to import loop issues, i put buttons and current in one file
# Used to modify the `record`
# Also the part of clicking a name to switch color
buttons = Blueprint("buttons", __name__)

class Button:
    def __init__(self, taskname:TaskName, no:int = 0) -> None:
        """
        taskname can be any string that is used in the `record` as key.
            e.g. "House Vacuuming"

        no is an integer representing the index of the person in the record.
            For task requiring only one person, it should be 0, and for
            task requiring more than person, say n persons, it should cover 
            from 0 to n - 1 (e.g. 0 and 1 for 2 persons)
        """
        self.taskname = taskname
        self.no = no
        # Generate url automatically with taskname and no
        buttons.add_url_rule(
            f"/{taskname_to_url_part(taskname)}{no}",
            endpoint = f"{taskname_to_url_part(taskname)}{no}",
            view_func= self._create_route()
        ) 

    def _create_route(self):
        """
        Used only in __init__
        Flip the boolean value of the person state in `record`
        """
        def button_route():
            this_week:RecordGet = current.current_week_record()
            name = tuple(this_week[self.taskname][0].keys())[self.no]
            this_week[self.taskname][0][name] = not this_week[self.taskname][0][name]
            return redirect(CLEANING_SCHEDULES_URL_PREFIX)
        return button_route

    def get_url(self) -> str:
        """Return the full url of the button"""
        return (
            f"{CLEANING_SCHEDULES_URL_PREFIX}{BUTTONS_URL_PREFIX}/" +
            f"{taskname_to_url_part(self.taskname)}{self.no}"
        )

# Instantiate all buttons
all_buttons = {
    "House Vacuuming": (Button("House Vacuuming", 0),  Button("House Vacuuming", 1)),
    "Kitchen Cleaning": (Button("Kitchen Cleaning", 0),  Button("Kitchen Cleaning", 1)),
    "Basement Cleaning": (Button("Basement Cleaning"),),
    "Plastic Garbage": (Button("Plastic Garbage"),),
    "Organic Garbage": (Button("Organic Garbage"),),
    "Cardboard Garbage": (Button("Cardboard Garbage"),),
    "Toilet Cleaning": (Button("Toilet Cleaning"),),
    "Glass Garbage": (Button("Glass Garbage"),),
}



class Current:
    def __init__(self) -> None:
        # Well, maybe i should have name them as _week_no and _year and
        # use @property since they should only be modified with methods
        # But i am too lazy to refactor it, test it and blablabla
        self.week_no, self.year = None, None
        self.reset_to_current_week()
        # Generated by ChatGPT 4o with modification
        self.timer_thread = None
        self.stop_event = threading.Event()
        self.lock = threading.Lock()
        # reset every 2 minutes
        self.start_timer()
    
    def reset_to_current_week(self) -> None:
        """Setter: Set to current week"""
        self.week_no, self.year = weekyear_to_tuple(get_today_weekyear())
    
    def next_week(self) -> None:
        """Setter: Set to next week"""
        self.week_no, self.year = weekyear_to_tuple(
            next_week_weekyear(tuple_to_weekyear((self.week_no, self.year)))
        )
    
    def current_week_record(self) -> RecordGet:
        """Retrieve a dictionary with"""
        return record[tuple_to_weekyear((self.week_no, self.year))]
    
    def get_weekyear(self) -> WeekYear:
        """Getter method"""
        return tuple_to_weekyear((self.week_no, self.year))

    def html_table(self) -> str:
        """
        Generate a 4-column table in html with global `record`
        """
        week:RecordGet = record[self.get_weekyear()]
        table = HtmlTable(len(week), 4, "center")
        for row_no, item in enumerate(week.items()):
            taskname, task = item
            task:tuple[dict[Name:bool], str]
            # The first column
            table[row_no, 0] = html_p(taskname, "taskname")
            # The second column
            for no, item in enumerate(task[0].items()):
                name, state = item
                table[row_no, 1] += html_p(html_a(
                    all_buttons[taskname][no].get_url(), 
                    name,
                    "green" if state else "red",
                ))
            # The third column
            table[row_no, 2] += html_p(task[1])
            # The forth column
            table[row_no, 3] += html_a(
                (
                    CLEANING_SCHEDULES_URL_PREFIX + MORE_INFO_URL_PREFIX + 
                    f"/{taskname_to_url_part(taskname)}"
                ),
                "More Info"
            )
        return str(table)
    
    # Methods below are generated by ChatGPT-4o, with some modification    
    def start_timer(self, seconds=CURRENT_DEFAULT_TIMER_INTERVAL):
        """
        Starts or restarts the timer to call `reset_to_current_week` every `seconds`.
        """
        self.stop_timer()  # Ensure no duplicate timers
        self.stop_event.clear()

        def timer_task():
            while not self.stop_event.wait(seconds):  # Wait for the interval or stop event
                # print("current is now reset")
                self.reset_to_current_week()
        
        self.timer_thread = threading.Thread(target=timer_task, daemon=True)
        self.timer_thread.start()
        # print(f"Timer started with interval of {seconds} seconds.")
    
    def reset_timer(self, seconds=CURRENT_DEFAULT_TIMER_INTERVAL):
        """
        Resets the timer with a new interval or restarts the current one.
        """
        # print(f"Timer reset with interval of {seconds} seconds.")
        self.start_timer(seconds)
    
    def stop_timer(self):
        """
        Stops the timer if it is running.
        """
        with self.lock:
            if self.timer_thread and self.timer_thread.is_alive():
                self.stop_event.set()
                self.timer_thread.join()
                # print("Timer stopped.")
                self.timer_thread = None


current = Current()
